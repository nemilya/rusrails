h1. Настройка I18n

h4. Использование различных бэкендов

По некоторым причинам простой бэкенд, поставляющийся с Active Support, осуществляет только "простейшие вещи, в которых возможна работа" _Ruby on Rails_ (или, цитируя Википедию, Интернационализация это процесс разработки программного обеспечения таким образом, что оно может быть адаптировано к различным языкам и регионам без существенных инженерных изменений. Локализация это процесс адаптации программы для отдельного региона или языка с помощью добавления специфичных для локали компонентов и перевод текстов), что означает то, что гарантируется работа для английского и, как побочный эффект, для схожих с английским языков. А также, простой бэкенд способен только читать переводы, а не динамически хранить их в каком-либо формате.

Впрочем, это не означает, что вы связаны этими ограничениями. Гем Ruby I18n позволяет с легкостью заменить простой бэкенд на что-то иное, более предпочтительное для ваших нужд. К примеру можно заменить его на бэкенд Globalize's Static:

<ruby>
I18n.backend = Globalize::Backend::Static.new
</ruby>

Также можно использовать бэкенд Chain для связывания различных бэкендов вместе. Это полезно при использовании стандартных переводов с помощью простого бэкенда, но хранении переводов приложения в базе данных или других бэкендах. Например, можно использовать бэкенд Active Record и вернуться к простому бэкенду (по умолчанию):

<ruby>
I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)
</ruby>

h4. Использование различных обработчиков исключений

API I18n определяет следующие исключения, вызываемые бэкендами, когда происходят соответствующие неожидаемые условия:

<ruby>
MissingTranslationData       # не обнаружен перевод для запрашиваемого ключа
InvalidLocale                # локаль, установленная I18n.locale, невалидна (например, nil)
InvalidPluralizationData     # была передана опция count, но данные для перевода не могут быть возведены во множественное число
MissingInterpolationArgument # перевод ожидает интерполяционный аргумент, который не был передан
ReservedInterpolationKey     # перевод содержит зарезервированное имя интерполяционной переменной (т.е. scope, default)
UnknownFileType              # бэкенд не знает, как обработать тип файла, добавленного в I18n.load_path
</ruby>

API I18n поймает все эти исключения, когда они были вызваны в бэкенде, и передаст их в метод default_exception_handler. Этот метод перевызовет все исключения, кроме исключений +MissingTranslationData+. Когда было вызвано исключение +MissingTranslationData+, он возвратит строку сообщения об ошибке исключения, содержащую отсутствующие ключ/пространство имен.

Причиной для этого является то, что при разработке вам обычно хочется, чтобы вьюхи рендерились несмотря на отсутствующие переводы.

Впрочем, в иных ситуациях, возможно, захочется изменить это поведение. Например, обработка исключений по умолчанию не позволяет просто ловить отсутствующие переводы во время автоматических тестов. Для этой цели может быть определен иной обработчик исключений. Определенный обработчик исключений должен быть методом в модуле I18n:

<ruby>
module I18n
  def self.just_raise_that_exception(*args)
    raise args.first
  end
end

I18n.exception_handler = :just_raise_that_exception
</ruby>

Это перевызовет все пойманные исключения, включая +MissingTranslationData+.

Другим примером, когда поведение по умолчанию является менее желательным, является Rails TranslationHelper, который предоставляет метод +#t+ (то же самое, что +#translate+). Когда в этом контексте происходит исключение +MissingTranslationData+ хелпер оборачивает сообщение в span с классом CSS +translation_missing+.

Чтобы это осуществить, хелпер заставляет +I18n#translate+ вызвать исключения, независимо от того, какой обработчик исключений установлен, определяя опцию +:raise+:

<ruby>
I18n.t :foo, :raise => true # всегда перевызывает исключения из бэкенда
</ruby>
